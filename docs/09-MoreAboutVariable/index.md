#  変数についてより詳しく

C言語勉強会 第九回

kumar8600  
June 2, 2013

----
###  今回の内容

* 型変換
    * 明示的型変換（キャスト）
    * 暗黙の型変換
* データ型
    * 符号の有無
    * 最大値・最小値
* スコープ
    * 変数が存在する範囲
* 記憶クラス指定子
    * 変数の保存方法を指定する
* 型修飾子
    * 変数の属性を指定する

----
##  型変換

----
###  明示的型変換（キャスト）

*強制的に別の型に変換* したいときに用いる。

####  文法

	(型)式

####  int変数 i をdouble型に変換する例

	(double)i


----
###  暗黙の型変換

####  代入時の変換

左辺の型と右辺の型が異なっている場合は、 *左辺の型に変換* される。

次の例では、 a は小数部の1415が切り捨てられて「3」になる。

	int a;
	double x = 3.1415;
	a = x;


* 代入時にかかわらず、C言語の型変換は四捨五入ではなく切り捨てであることに注意されたい。
	* 上の例で例え x が　3.99999 だったとしても a は 3 になる。

----
####  式の中で行われる変換

式の中で異なる型の定数や変数が現れたときは、 *精度の高い型に統一* される。

* 精度の順番
	* `char` < `int` < `long` < `float` < `double`

----
###  3 ÷ 2 は 1 ？？？？？？

下の式では x は 1 になってしまう。

	int a = 3;
	int b = 2;

	float x = a / b;

* C言語では右辺での計算が行われたあと、代入するときになって初めて左辺の型への型変換が行われる。
* だから、左辺の x の型がfloatであるのに、   
右辺のaとbが共にint型であるから、int型の値が代入されてしまった。

こうすれば右辺はfloat型の精度で計算され、 x は 1.5 になる。

	float x = (float)a / b;


----
##  データ型をもっと知ろう

----
###  符号の有無

以下のキーワードを整数型の前後に付加することで符号の有無を指定する。

<table>
    <tr>
        <th>
            キーワード
        </th>
        <th>
            意味
        </th>
    </tr>
    <tr>
        <td>
            signed
        </td>
        <td>
            符号あり
        </td>
    </tr>
    <tr>
        <td>
            unsigned
        </td>
        <td>
            符号なし
        </td>
    </tr>
</table>

符号無しのint型変数を宣言するには以下のように書く。

    unsigned int x;

* 符号がないので、当然負の数は扱えない。
* これらのキーワードを省略した場合、自動的に`signed`が指定される。<small>（ただしchar型は処理系による）</small>

----

###  なぜわざわざ符号なしの変数なんか宣言するのか？

それは、符号なしの時のほうが、扱える値の範囲が正の方向に長いので、そのほうが便利な場面があるからだ。

* <small>これは実際にそういった場面が来ればわかると思う。</small>

----
###  整数型の最大値・最小値

変数の型によって、扱える値の範囲は変わる。

<table>
  <tr>
    <th>
      符号
    </th>
    <th>
      型
    </th>
    <th>
      容量
    </th>
    <th>
      値の範囲
    </th>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      char
    </td>
    <td rowspan="2">
      1
    </td>
    <td>
        -128 ～ 127
    </td>
  </tr>
  <tr>
    <td>
      unsinged
    </td>
    <td>
        0 ～ 255
    </td>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      short
    </td>
    <td rowspan="2">
      2
    </td>
    <td>
        -32,768 ～ 32,767
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        0 ～ 65,535
    </td>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      int<small>※</small>
    </td>
    <td rowspan="2">
      4
    </td>
    <td>
        -2,147,483,648 ～ 2,147,483,647(±約21億)
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        0～4,294,967,295(約42億)
    </td>
  </tr>
</table>
* <small>※大半の32bit、64bit環境において。</small>

----

<table>
  <tr>
    <th>
      符号
    </th>
    <th>
      型
    </th>
    <th>
      容量
    </th>
    <th>
      値の範囲
    </th>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      long
    </td>
    <td rowspan="2">
      4
    </td>
    <td>
        -2,147,483,648 ～ 2,147,483,647(±約21億)
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        0～4,294,967,295(約42億)
    </td>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      long long
    </td>
    <td rowspan="2">
      8
    </td>
    <td>
        -9,223,372,036,854,775,808 ～ 9,223,372,036,854,775,807(±約922京)
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        0～18,446,744,073,709,551,615(約1844京)
    </td>
  </tr>
</table>

* <small>これはWindows 32/64bit環境における値である。</small>
* <small>UNIX 64bit環境ではlong型はlong long型と同じ大きさになる。</small>
* <small>`short`, `long`, `long long` は `~ int`の略である。</small>
* <small>Cの規格では、変数型の大きさは定義されていない。</small>

----
###  浮動小数点型

精度が低い順に、

* `float`
* `double`
* `long double`

がある。

* それぞれが、具体的にどの程度の範囲の値を扱えるかは環境に依存する。（整数型もそうだが）

* とりあえずdouble型を使うと高速だし十分な精度があると思う。

----
###  sizeof 演算子

sizeofに渡された型や変数のメモリサイズを返す。

####  文法

	sizeof 型名or変数名
	または
	sizeof(型名or変数名)

####  型のメモリサイズを得る例

	int integerSize = sizeof(int);

* integerSizeにはint型のメモリサイズ、4が入る
* これは int 型は４バイトのメモリを使うという意味だ。

* <small>（int型のメモリサイズは環境依存）</small>

----
####  変数のメモリサイズを得る例

	int i = 10;
	int integerSize = sizeof(x);

* 型名ではなく、変数名を入れてもよい。
* integerSizeにはint型のメモリサイズ、4が入る

* <small>（int型のメモリサイズは環境依存）</small>

----
####  配列のメモリサイズを得る例

	int arr[10];
	int arrSize = sizeof(arr);

* arrSizeには配列のメモリサイズ、40が入る。
* これは、サイズが4であるint型変数を10個持っているからである。

* <small>（int型のメモリサイズは環境依存）</small>

----
####  配列の要素数を算出

	配列の要素数 = sizeof(配列名) / sizeof(配列の要素の型)
	すなわち
	配列の要素数 = sizeof(配列名) / sizeof(配列名[0])

* これは、配列のメモリサイズが `配列の要素の型のサイズ` * `配列の要素数` だからである。

----
###  接尾語

式に直接、定数を書き込むとき、接尾語を付けることでその型を指定出来る。

	float x = 3.0f / 2.0f;  // 3.0と2.0がfloat型であることを示している。

####  整数定数の接尾語  

<table>
	<tr>
		<th>
			接尾語
		</th>
		<th>
			型
		</th>
	</tr>
	<tr>
		<td>
			なし
		</td>
		<td>
			int 以上の符号あり整数型
		</td>
	</tr>
	<tr>
		<td>
			u または U
		</td>
		<td>
			unsigned int 以上の符号なし整数型
		</td>
	</tr>
	<tr>
		<td>
			l または L
		</td>
		<td>
			long int 以上の符号あり整数型
		</td>
	</tr>
	<tr>
		<td>
			ll または LL
		</td>
		<td>
			long long int
		</td>
	</tr>
</table>

----

####  浮動小数点定数の接尾語  

<table>
	<tr>
		<th>
			接尾語
		</th>
		<th>
			型
		</th>
	</tr>
	<tr>
		<td>
			なし
		</td>
		<td>
			double
		</td>
	</tr>
	<tr>
		<td>
			f または F
		</td>
		<td>
			float
		</td>
	</tr>
	<tr>
		<td>
			l または L
		</td>
		<td>
			long double
		</td>
	</tr>
</table>

####  例

	423		: int
	423L	: long

	423.0f	: float
	423.0	: double

----
## スコープ

----
###  ブロック

`{`と`}`に囲まれた領域をブロックと呼ぶ。

----
###  ローカル変数

プログラムの一部分でしかアクセスできない変数のこと（グローバル変数の逆）

* 宣言された場所からその変数が宣言されたブロックを抜けるまででしかアクセス出来ない

----

    #include <stdio.h>
    
    void print_a() {
        int o = a;
        printf("%d\n", o);
    }
    
    int main(void) {
        int a = 10;  /* ここから変数 a にアクセスできる */
        
        print_a();
        
        return 0;
    } /* ここで変数 a は開放され、消滅する */

* a はローカル変数なので、その変数が宣言された場所からその変数が定義されたブロックを抜けるまででしかアクセス出来ない。
* だから、上の例は、コンパイル時にエラーとなる。 

----
###  スコープ

先程の例では a にアクセスできるのはmain関数の終わりまでである。

* こういったある変数や関数が特定の名前で参照される範囲のことを、 *スコープ* と呼ぶ。

* スコープ外で同名の別の変数を新たに宣言することが可能である。

* このスコープがなるべく狭くなるようにプログラムを書くと、ミスの少ないコードを書ける。特にグローバル変数は必要最小限の量にしよう。

----
###  グローバル変数

全てのスコープからアクセスできる変数。どこの関数の中でもない、プログラムの最も外側の部分に書く。

    #include <stdio.h>
    
    int a = 3;
    
    int main(void) {
        
        printf("%d\n", a);
        
        return 0;
    }

* 上の例では a はグローバル変数であり、すべてのブロック（関数）からアクセスできる。
* 上の例では a の値 3 が出力される。

----
###  変数の優先度

ブロックの外側で宣言された変数よりも、内側で宣言された変数が優先される。 

    #include <stdio.h>
    
    int a = 3;
    
    int main(void) {
        int a = 10;
        
        printf("%d\n", a);
        
        return 0;
    }

* 上の例では、main関数の中で宣言された方の a の値 10 が出力される。  


----
###  理解の再確認

今までの内容を理解しているなら、下のプログラムを実行するとどう出力されるかわかるはずだ。

    #include <stdio.h>
    
    int main(void) {
        int a = 10;
    
      if(1) {
        int a = 20;
        printf("%d\n", a);
      }
        
        printf("%d\n", a);
    
      return 0;
    }

----

main関数ではじめに a を宣言し、10で初期化した。その後、if文の中でもう一度 a という名前の変数を宣言したが、これらが全く別の変数であることを意識出来れば、なんの迷いもない問題だ。

* 答えは`20(改行)10`。

----
##  記憶クラス指定子

----
###  記憶クラス指定子

変数の保存方法を更に細かく指定する

####  文法

通常の変数の宣言の前につける。

    記憶クラス指定子 型名 変数名;

####  例

	static int a;

----

####  以下の五つが存在する

* static
* extern
* auto - (時代遅れ)
* register - (時代遅れ)
* typedef - （構文の都合で分類されているだけ）

----
###  auto | 自動変数

プログラム中の宣言されたブロック内でのみ使用できる変数。  
つまり、 *今まで使ってきた普通の変数* 。

####  文法

    auto 型名 変数名;
    または
    型名 変数名;


----
####  補足

* auto句を付けたところで全く意味は無い。と言うか混乱を招くので付けないほうがいい。
* <small>そんな句がなぜあるか？というと、C言語の前身であるB言語は変数の宣言に`auto 変数名`と書いたからである。型名が無いが、B言語には整数型しかなかった。</small>

----

####  自動変数のココが自動

*特定の区域内に到達すると自動的に変数領域を確保し* 、 *その区域を脱すると自動的にその領域を開放して消滅する* 点が自動

----
####  例

    void print_a() {
        int o;
        o = 10;
        printf("%d\n", o);
    }

* <small>この関数を呼び出した場合、  
関数を呼び出すと同時にメモリーのどこかあいてるところに int型変数o のための領域を確保し、  
関数を実行しおわると先ほど確保した 変数o の領域を開放し消滅する。</small>

* 砕いていうと、関数を呼び出すたび変数を作り、抜けるとき変数を消してるだけである。

	* この仕組みがスコープを生み出している。

----
###  static | 静的変数

どこに宣言していようとも関係なく、*プログラムの実行開始時にメモリ上に作られ、初期値も与えられる変数* 。

####  文法

	static 型名 変数名;

* *関数が終了しても値を保持しているローカル変数* 。という認識で問題ないだろう。
* auto変数の逆

####  例

----

    #include <stdio.h>
    
    void printCalledNum() {
        static int n = 0;
        n++;
        printf("%d回目の呼び出し\n", n);
    }
    
    int main(void) {
        
        printCalledNum();
        printCalledNum();
        printCalledNum();
        
        return 0;
    }

* printCalledNum関数の n は静的変数なので、printCalledNum関数を抜けだしても値は保持されている。

----
####  グローバル変数でのstatic

グローバル変数にstaticをつけると、今まで説明した意味と全く違う意味になる。

####  静的変数は必ず初期化される

静的変数は、具体的な初期値を与えなくても、必ず 0 で初期化されることが保証されている。

* なので、前のページの例ではわかりやすいように 0 で n を初期化しているが、書かなくても同じ結果である。

* もしかして知らなかった人もいるかもしれないが、逆に普通の変数や配列は、宣言しても初期値は入っていないので注意。<small>厳密にはメモリ上に残ったゴミが初期値。</small>


----
###  extern

C言語でも複数ファイルを使ったプログラムをかけるのだが、その際に別のファイルに書かれたグローバル変数や関数を使うためにextern宣言が必要になる。

* この話は面白いのだが奥が深いので、今回は省略する。知りたかったらググるといい。

----
###  register | レジスター変数（時代遅れらしい）

コンピューターには主記憶装置である「メモリ」の他に、CPUに内蔵されていて、メモリと比べるととてつもなく速く、低容量な「 *レジスタ* 」がある。実はCPUによる計算は、メモリに入っている値を一度レジスタにコピーしてから行われている。（なんか最近は違うらしい）

そんな高速なレジスタに変数を格納したいとき、この指定子を使う。

	register int a;

* register変数は「出来れば」レジスタに変数を格納する。容量が足りないとき等は結局いつもどおりメモリを使うので注意。

* あと、register変数のアドレスを得ることは出来ない。

----

* ちなみに、 *今はコンパイラーの最適化が凄いので、こんなもの書く必要はない* （凄いプログラマーならあるいは）。私も書いたことないです。

----
###  typedef

*データ型に新しい名前（別名）をつける。*

<small>構造体を宣言する際にも何気なく使ってきたと思う。</small>

例えば、int に自分の好きな別名をつけるには、

	typedef int Seisu;

このように書く。この例では int に Seisu という別名をつけた。なので以降、

	Seisu n;

と書くことでも int 型変数 n を宣言できる。

----
###  typedef | よくある使用例

unsigned int に uint という別名をつける

	typedef unsigned int uint;

ある構造体を名前をつけ宣言する。

	typedef struct {
		char name[20];
		double height;
		double weight;
	} HUMAN;

* name、height、weightをもつ構造体に HUMAN という名前をつけた。

----
##  型修飾子


----
###  型修飾子

データ型を用途に応じてきめ細かく指定する。

####  文法

変数を宣言する際、型の前後に付加して使う。

	型修飾子 型名 変数名;
	または
	型名 型修飾子 変数名;

####  例

    const int a;
    int const a;

----

####  補足

* 型修飾子が付いている型と付いてない型は別の型扱いされる。
	* <small>例:）int と const int は別の型</small>

####  以下の二つについて紹介する。

* const
* volatile

----
###  定数（const）

指定した変数が定数であることを指定する。

* 定数とは初期化出来ても、書き換え出来ない変数のことである。
* 書き換えを行うようなコードを書いた場合、コンパイルの時点でエラーになる。

####  文法

	const 型名 変数名;
	または
	型名 const 変数名;

----
####  例
    #include <stdio.h>
        
    int main(void) {
        
        const int a = 10;
        a += 2;
        
        printf("%d\n", a);

        return 0;
    }

* 定数として宣言した `a` を `a += 2`で、値を書き換えようとしているため、このプログラムはコンパイル時にエラーする。

----

####  補足

* 定数の初期化は宣言時にしか行えないので注意。

* ポインタ定数の場合特別な挙動をする。これを積極的に使うと便利である。ポインタを紹介してないから今は書かない。

* わざわざ変数を定数にするのは、プログラムを書く際のミスを減らすためである。変更しないつもりの変数は積極的に定数として宣言すべきである。

----
###  volatile変数

コンパイラによる最適化を行わない変数。

今のコンパイラは頭がいいので、私たちの書いたなプログラムをできるだけ素晴らしい効率で動くように最適化する。

だが、マルチスレッドなプログラム等、コンパイラの設計の想定を超えるプログラムを書いた場合、逆にその最適化のせいでプログラムが正常に作動しなくなることがある。

* その際に、この変数にはお節介するなよ？とコンパイラに伝えるための修飾子である。

----

###  次回

* アドレス
    * 変数のメモリ上での座標
* ポインタ変数
    * アドレスを代入するための変数の型