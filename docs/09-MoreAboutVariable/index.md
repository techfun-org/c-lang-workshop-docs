#  変数についてより詳しく

C言語勉強会 第九回

kumar8600  
June 2, 2013

----
###  今回の内容

* 型変換
    * 暗黙の型変換
    * 明示的型変換（キャスト）
* データ型
    * 符号の有無
    * 最大値・最小値
* スコープ
    * 変数が存在する範囲
* 記憶クラス指定子
    * 変数の保存方法を指定する
* 型修飾子
    * 変数の属性を指定する

↓次回やろうかな↓

* アドレス
    * 変数のメモリ上での座標
* ポインタ変数
    * アドレスを代入するための変数の型

----
##  型変換

----
###  暗黙の型変換


----
###  明示的型変換（キャスト）

----
##  データ型をもっと知ろう

----
###  符号の有無

以下のキーワードを整数型の前後に付加することで符号の有無を指定する。

<table>
    <tr>
        <th>
            キーワード
        </th>
        <th>
            意味
        </th>
    </tr>
    <tr>
        <td>
            signed
        </td>
        <td>
            符号あり
        </td>
    </tr>
    <tr>
        <td>
            unsigned
        </td>
        <td>
            符号なし
        </td>
    </tr>
</table>

符号無しのint型変数を宣言するには以下のように書く。

    unsigned int x;

符号がないので、当然負の数は扱えない。

これらのキーワードを省略した場合、自動的に`signed`が指定される。<small>ただしchar型は処理系による</small>

----

なぜわざわざ符号なしの変数なんか宣言するのか？  
それは、符号なしの時のほうが、扱える値の範囲が正の方向に長いので、そのほうが便利な場面があるからだ。<small>これは実際にそういった場面が来ればわかると思う。</small>

----
###  整数型の最大値・最小値

変数の型によって、扱える値の範囲は変わる。

<table>
  <tr>
    <th>
      符号
    </th>
    <th>
      型
    </th>
    <th>
      バイト数
    </th>
    <th>
      値の範囲
    </th>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      char
    </td>
    <td rowspan="2">
      1
    </td>
    <td>
        -128 ～ 127
    </td>
  </tr>
  <tr>
    <td>
      unsinged
    </td>
    <td>
        0 ～ 255
    </td>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      short
    </td>
    <td rowspan="2">
      2
    </td>
    <td>
        -32,768 ～ 32,767
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        -32,768 ～ 32,767
    </td>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      int
    </td>
    <td rowspan="2">
      4
    </td>
    <td>
        -2,147,483,648 ～ 2,147,483,647(±約21億)
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        0～4,294,967,295(約42億)
    </td>
  </tr>
</table>

----

<table>
  <tr>
    <th>
      符号
    </th>
    <th>
      型
    </th>
    <th>
      バイト数
    </th>
    <th>
      値の範囲
    </th>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      long
    </td>
    <td rowspan="2">
      4
    </td>
    <td>
        -2,147,483,648 ～ 2,147,483,647(±約21億)
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        0～4,294,967,295(約42億)
    </td>
  </tr>
  <tr>
    <td>
      signed
    </td>
    <td rowspan="2">
      long long
    </td>
    <td rowspan="2">
      8
    </td>
    <td>
        -9,223,372,036,854,775,808 ～ 9,223,372,036,854,775,807(±約922京)
    </td>
  </tr>
  <tr>
    <td>
      unsigned
    </td>
    <td>
        0～18,446,744,073,709,551,615(約1844京)
    </td>
  </tr>
</table>

<small>以上の表はWindows 32bit環境、64bit環境でのものである。UNIX 64bit環境ではlong型はlong long型と同じ大きさになる。  
しかも、Cの規格はこれと同一ではない。[C data types - Wikipedia](http://en.wikipedia.org/wiki/C_data_types)を参照。  
`short`, `long`, `long long` は `~ int`の略である。</small>

----
###  浮動小数点型

精度が低い順に、`float`, `double`, `long double` がある。

とりあえずdouble型を使うと高速だし十分な制度があると思う。

----
## スコープ

----
###  ブロック

`{`と`}`に囲まれた領域をブロックと呼ぶ。

----
###  グローバル変数

全てのスコープからアクセスできる変数

    #include <stdio.h>
    
    int a = 3;
    
    int main(void) {
        
        printf("%d\n", a);
        
        return 0;
    }

上の例では a の値 3 が出力される。

a のようにどこの関数の中でもない、プログラムの最も外側の部分に書かれた変数は、すべての関数からアクセスできる。

こういった変数が *グローバル変数* である。

----
###  ローカル変数

プログラムの一部分でしかアクセスできない変数のこと（グローバル変数の逆）

----

    #include <stdio.h>
    
    void print_a() {
        int o = a;
        printf("%d\n", o);
    }
    
    int main(void) {
        int a = 10;  /* A */
        
        print_a();
        
        return 0;
        /* B */
    }

上の例は、コンパイル時にエラーとなる。 
ローカル変数は、その変数が宣言された場所からその変数が定義されたブロックを抜けるまででしかアクセス出来ないからだ。

この例では a にアクセスできるのはAからBまでである。

こういったある変数や関数が特定の名前で参照される範囲のことを、 *スコープ* と呼ぶ。

----
###  変数の優先度

ブロックの外側で宣言された変数よりも、内側で宣言された変数が優先される。 

    #include <stdio.h>
    
    int a = 3;
    
    int main(void) {
        int a = 10;
        
        printf("%d\n", a);
        
        return 0;
    }

上の例では、main関数の中で宣言された方の a の値 10 が出力される。  


----
###  理解しているか？

今までの内容を理解しているなら、下のプログラムを実行するとどう出力されるかわかるはずだ。

    #include <stdio.h>
    
    int main(void) {
        int a = 10;
    
      if(1) {
        int a = 20;
        printf("%d\n", a);
      }
        
        printf("%d\n", a);
    
      return 0;
    }

----

main関数ではじめに a を宣言し、10で初期化した。その後、if文の中でもう一度 a という名前の変数を宣言したが、これらは全く別の変数であることを意識出来れば、なんの迷いもない問題だ。答えは`20(改行)10`。

----
##  記憶クラス指定子

----
###  記憶クラス指定子

変数の保存方法を更に細かく指定する

    static int a;

この`static`のように、通常の変数の宣言の前につける。

以下の五つが存在する

* static
* extern
* 時代遅れな指定子
    * auto
    * register
* typedef
    * 構文の都合で分類されているだけ
----
###  自動変数（auto）

プログラム中の宣言されたブロック内でのみ使用できる変数。  
つまり、 *今まで使ってきた普通の変数* 。

    auto int a;

または

    int a;

のように書く。auto句を付けたところで全く意味は無い。と言うか混乱を招くので付けないほうがいい。

そんな句がなぜあるか？というと、C言語の前身であるB言語は変数の宣言に`auto 変数名`と書いたからである。型名が無いが、B言語には整数型しかなかった。

----
###  自動変数のココが自動

*特定の区域内に到達すると自動的に変数領域を確保し* 、 *その区域を脱すると自動的にその領域を開放して消滅する* 点が自動

    void print_a() {
        int o;
        o = 10;
        printf("%d\n", o);
    }

この関数を呼び出した場合、  
関数を呼び出すと同時にメモリーのどこかあいてるところに int型変数o のための領域を確保し、  
関数を実行しおわると先ほど確保した 変数o の領域を開放し消滅する。

----

砕いていうと、関数を呼び出すたび変数を作り、抜けるとき変数を消してるだけである。

----
###  静的変数（static）

どこに宣言していようとも関係なく、*プログラムの実行開始時にメモリ上に作られ、初期値も与えられる変数* 。

*関数が終了しても値を保持しているローカル変数* 。という認識で問題ないだろう。

----

    #include <stdio.h>
    
    void printCalledNum() {
        static int n = 0;
        n++;
        printf("%d回目の呼び出し\n", n);
    }
    
    int main(void) {
        
        printCalledNum();
        printCalledNum();
        printCalledNum();
        
        return 0;
    }

printCalledNum関数の n は静的変数なので、printCalledNum関数を抜けだしても値は保持されている。

----
###  静的変数は必ず初期化される

静的変数は、具体的な初期値を与えなくても、必ず 0 で初期化されることが保証されている。

なので、前のページの例ではわかりやすいように 0 で n を初期化しているが、書かなくても同じ結果である。

もしかして知らなかった人もいるかもしれないが、逆に普通の変数や配列は、宣言しても初期値は入っていないので注意。<small>厳密には初期値はメモリ上に残ったゴミ</small>

----
###  extern宣言

C言語でも複数ファイルを使ったプログラムをかけるのだが、その際に別のファイルに書かれたグローバル変数や関数を使うためにextern宣言が必要になる。

この話は面白いのだが奥が深いので、今回は省略する。知りたかったらググるといい。

----
###  レジスター変数（register）（時代遅れらしい）

コンピューターには主記憶装置である「メモリ」の他に、CPUに内蔵されていて、メモリと比べるととてつもなく速く、低容量な「 *レジスタ* 」がある。実はCPUによる計算は、メモリに入っている値を一度レジスタにコピーしてから行われている。（なんか最近は違うかもしれない）

そんな高速なレジスタに変数を格納したいとき、この指定子を使う。

    register int a;

register変数は「出来れば」レジスタに変数を格納する。容量が足りないとき等は結局いつもどおりメモリを使うので注意。

あと、register変数のアドレスを得ることは出来ない。

----

ちなみに、 *今はコンパイラーの最適化が凄いので、凄いプログラマーじゃないとこんなもの書く必要はない* 。私も書いたことないです。

----
###  typedef

----
##  型修飾子

----
###  型修飾子

データ型を用途に応じてきめ細かく指定する。

変数を宣言する際、型の前後に付加する。

    const int a;

または

    int const a;

のように記述する。

型修飾子が付いている型と付いてない型は別の型扱いである。

----

以下の二つについて紹介する。

* const
* volatile

----
###  定数（const）

値を書き換えることが出来ないデータ型。

    #include <stdio.h>
        
    int main(void) {
        
        const int a = 10;
        a += 2;
        
        printf("%d\n", a);

        return 0;
    }

このプログラムはコンパイル時にエラーする。`a += 2`で、値を書き換えようとしたことが原因である。

----

また、定数の初期化は宣言時にしか行えないので注意。

ポインタ定数の場合特別な挙動をする。これを積極的に使うと便利である。ポインタを紹介してないから今は書かない。

----
###  volatile変数

コンパイラによる最適化を行わない変数。

通常のプログラミングでは関係ないが、マルチスレッドなプログラムを書いたりする際に必要になってくるらしい。  
これぼくよくわかんないんでググってください。