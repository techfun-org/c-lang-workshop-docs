#  アドレスとポインタ
C言語勉強会 第十回

kumar  
June 26, 2013  
[引用 : Programming Place Plus](http://www.geocities.jp/ky_webid/index.html)

----
###  今回の内容

* アドレス
	* 変数のメモリ上での座標
* ポインタ型
	* アドレスを格納するための変数の型
* ポインタ演算
	* ポインタ型変数の演算は特殊である
* ポインタを引数、戻り値にとる関数
	* ポインタ渡し
* 配列とポインタ
	* 配列は実はポインタに似ている

----
## アドレス

----
### アドレス

メモリ上の位置の一意な識別子

* C言語のアドレス空間は１次元である。
* そのアドレス空間上の座標（位置）を表現するのが、アドレスである。
* C言語では、単なる符号なし整数で表現される。
* C言語ではアドレスの単位はバイトである。
* C言語では通常、主記憶装置（物理メモリ）のアドレスを扱う。

----
### アドレス空間の大きさ

* 32bitOSを使っているなら32bit（4バイト）
* 64bitOSを使っているなら64bit（8バイト）

つまり、アドレスは下記の値を取りうる。

* 32bitOSなら0～4,294,967,295(約42億)
* 64bitOSなら0～18,446,744,073,709,551,615(約1844京)

----
### 変数のアドレス

変数はメモリのどこかに保存されていて、その座標を得ることが出来る。

#### 文法

	&変数名

#### 例
変数 x が宣言されているとすると

	&x

と書くことで、`変数xのアドレス`を得ることが出来る。

----
### 変数のアドレスは実行するごとに変わる

変数のためのメモリ領域の確保は、そのときメモリが空いているところのどこかになる。

#### 例
変数 x のアドレスを出力する

	#include<stdio.h>

	int main(void) {
		int x;
		printf("%p\n", &x);	/* %pはポインタのフォーマット指定子 */
		return 0;
	}

----
##### 出力結果の例

	0x7fff59161b48
	
この出力結果は実行するごとに違う。なぜなら、先程述べたように

> 変数のためのメモリ領域の確保は、そのときメモリが空いているところのどこかになる

からだ。

----
## ポインタ型

----
### ポインタ型

ある型 T の変数のアドレスを格納するための型

* ある型 T から派生されるポインタ型は *Tへのポインタ* と呼ぶ。
	* int → intへのポインタ
	* float → floatへのポインタ
* ポインタからも派生できる
	* intへのポインタ → intへのポインタへのポインタ → intへのポインタへのポインタへのポインタ → …

----
* ポインタ変数の実体は
	* 符号なし整数である。
	* アドレス空間の大きさと同じ大きさを持つ。
		* つまり、sizeof(ポインタ)は、32bit環境なら4、64bit環境なら8
* Tが違えば違うポインタ型として区別される。
	* 例えばint型へのポインタへfloat型へのポインタを代入することは出来ない（強制型変換なしには）
	
* ポインタに対しての演算は通常の演算と異なる。（後述）

----
### 宣言

#### 文法

	型 *変数名

	または

	型* 変数名

----

#### 例
intへのポインタ p を宣言する

	int *p;

x をint型変数とし、p にxのアドレスを代入する

	p = &x;

p を出力する

	printf("%p\n", p); /* %pはポインタのフォーマット指定子 */;

----
### 間接参照（デリファレンス）

ポインタが指し示す変数にアクセスする

#### 文法

	*ポインタ変数名

* 宣言のときと同じ記号 `*` を使っていることに注意。

----
#### 例
int型変数 x 、intへのポインタ p が宣言されていて、p には &x (xのアドレス)が代入されているとする。

ポインタ p から間接参照で x へ 10を代入する

	*p = 10;

ポインタ p から間接参照で x を出力する

	printf("%d\n", *p);

つまり、ここでは `*p` と書くと `x` と書くのと同じ動きをする。

----
### NULLポインタ
値 0 もしくは (void *) にキャストした 0 を持つポインタ

* メモリ上のどのアドレスも指していないという意味を持つ。

----
#### 例
ポインタ p をNULLポインタにする

	p = 0;

もしくは

	p = NULL;

* `NULL` は `0` もしくは `(void *)0` を示すマクロである。
	* ただしstddef.hをインクルードしなければ使えない。（stdio.hの中でstddef.hをインクルードしているのであまり問題にはならない）

----
## ポインタ演算

----
### ポインタ演算
ある型 `T` へのポインタ型変数 に `x` 足すと `x` の `sizeof(T)` 倍 足される

* 整数の加減算のみ可能。
* 引き算でも同様。
	* ただし、ポインタ同士の減算を行った場合異なる。（後述）
* インクリメント、デクリメントも同様

----
#### 例（コード片）
	int x;
	int *p = &x;

	printf("%p\n", p);
	p++;
	printf("%p\n", p);
	printf("%p\n", p + 2);

----
##### 出力結果
	0x7fff5a396b48
	0x7fff5a396b4c // インクリメントしたら 4 増えた
	0x7fff5a396b54 // 更に 2 足したら 8 増えた

xのアドレスは毎回違うのだが、三つの出力の差を見て欲しい。まず、`p`をインクリメントした結果、4増えている。次に `p + 2` を出力した場合も、8増えている。

----
この特徴は、配列のポインタへの演算に便利である。

#### 例（コード片）

	int arr[] = {10, 20, 30, 40};
	int* ap = &arr[0];
	printf("%d\n", *ap);
	ap++;
	printf("%d\n", *ap);

配列の要素はメモリ上に隙間なく順番に並ぶことが保証されているため、配列のi番目の要素へのポインタである `ap` をインクリメントするだけで、`ap`は 次の要素を指すようになる。

----
#### ポインタ同士の減算
a,bをT型変数へのポインタとし、`a - b` すると、その答えは `(a - b) / sizeof(T)`になる

* この値は、a と b の間に、T型変数が何個入る、という意味を持つと考えて良い。
* 計算結果の型は`ptrdiff_t`である。
	* だがint型で受け取ってもエラーにはならない


----
#### 例（コード片）
ポインタだけを使って、配列3番目の要素と1番目の要素の間にいくつ要素があるか計算する

	int arr[] = {10, 20, 30, 40, 50};
	int* a = &arr[3];
	int* b = &arr[1];
	printf("%d\n", a - b);

##### 出力結果

	2

----
## ポインタを引数、戻り値に取る関数

----
### ポインタを引数、戻り値に取る関数
通常の変数と同じようにポインタを引数、戻り値に取れる。

#### 例
int型へのポインタを引数にとり、アドレスと値を出力する関数。nをそのまま戻り値として返す。

	int *myPrint(int *n) {
		printf("アドレス: %p\n", n);
		printf("値: %d\n", *n);
		return n;
	}

----
### ポインタ渡し
渡されたポインタが指し示す変数を、前述の間接参照で書き換えることが出来る。

* あくまで渡されているのはポインタなので、そのポインタが示すアドレスにある変数を書き換えられる。

----
#### 例
引数に渡されたポインタ変数 n が示す先を 1 に書き換える関数

	void assignOne(int *n) {
		*n = 1;
	}

この関数を呼び出す例（コード片）

	int x = 100;
	assignOne(&x);
	printf("%d\n", x);

* x の値は最初 100 だったが、assignOne が x を書き換えたため、  `1` と出力される


----
### 値渡し
ポインタ渡しと逆の、今までどおりの普通な引数の渡し方

* 変数の値が仮引数へコピーされるので、ポインタ渡しのように引数を書き換えられることはない。

----
## 配列とポインタ

----
### 配列のアドレス
配列のアドレスとは、配列の0番目の要素のアドレスのことである。

	配列名

だけ書くと、配列の先頭のアドレスを示す。それは`&配列名[0]`と同じアドレスである。

----
#### 例（コード片）

	int arr[10];
	printf("%p\n", arr);
	printf("%p\n", &arr[0]);

##### 出力結果

	0x7fff5ed1db10
	0x7fff5ed1db10

当然アドレスなので毎回違う結果が出力されるが、arrと&arr[0]は同じなので、二行とも同じになる。

----
### 添字は糖衣構文

今まで配列 arr の i 番目の要素にアクセスするときは

	arr[i]

と書いてきたが、実はこれは

	*(arr + i)

の糖衣構文である。

> <small>糖衣構文（とういこうぶん）は、プログラミング言語において、読み書きのしやすさのために導入される構文  
定義上、糖衣構文はプログラムの意味としては同じものを、よりわかりやすい構文で書けるものを指す。  
[糖衣構文 - Wikipedia](http://ja.wikipedia.org/wiki/%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87)</small>

----
また、この添字は、配列以外の物にも使える。例えば、intへのポインタ p がある場合、

	*p

と

	p[0]

は同じである。(`p[0]` は、`*(p + 0)` つまり `*p` に展開されるから)  
<small>ただ、このような表現は遠回りで誤解を招くのでやめよう</small>

----
### ポインタで配列を代替できる
前述のとおり添字は単なるポインタ演算の糖衣構文であるから、配列のアドレスを代入したポインタで同じように扱える。

#### 例

	int arr[] = {10, 20, 30, 40, 50};
	int *p = arr;	/* 配列のアドレスを代入 */
	int i;
	for(i = 0; i < 5; i++)
		printf("%d\n", p[i]); /* 配列と同じようにアクセス */

だが、完全に配列の機能を代替出来るわけではない。（次項）

----
### 配列とポインタの違い
sizeof演算子で大きさを得たとき、配列は配列の大きさが得られるが、ポインタだとポインタの大きさしか得られない。

#### 例

	int arr[] = {0, 1, 2, 3, 4};
	printf("%d\n", sizeof arr);
	
	int *p = arr;
	printf("%d\n", sizeof p);

##### 出力例

	20	// 配列arrの大きさ（sizeof(int) * 要素数 = 4 * 5 = 20）
	8	// ポインタの大きさ（sizeof(int *)）

----
### 配列を引数にとる関数
関数の引数として配列をとることも出来る。

#### 例
配列arrのn番目までの要素をすべて出力する関数

	int func(int arr[], int n) {
		int i;
		for(i = 0; i < n; i++)
			printf("%d\n", arr[i]);
	}

----
#### 実体はポインタ
実は、配列を関数の引数としてとったように見えるが、実体はただの配列の最初の要素へのポインタである。

* 仮引数における `int arr[]` は `int *arr` の糖衣構文である。
* よって、sizeof演算子により配列の要素数を求めることは出来ない。
	* （配列の大きさでなく、ポインタの大きさが返ってきてしまうから）
* また、これもまた前述のポインタ渡しであるから、値の書き換えが可能である。

----
#### 文法
以下のプロトタイプはすべて正しく、同じ意味である

	int func(int arr[]);
	int func(int arr[10]);
	int func(int *arr);

* どれもint型配列arrを引数にとる関数。
	* 2行目の引数arrの添字に10と書かれているが、無視される

----
#### 例
前のページの例の関数 func のプロトタイプはこう書き換えることが出来る。

	int func(int *arr, int n);

----
## 次回

----
### 次回予告

* 動的配列
	* 要素数が可変な配列
	* ポインターの代表的な使用例のひとつ

----
